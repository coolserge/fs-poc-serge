<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS CDN -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
        integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <!-- LightningFS and Isomorphic-git scripts-->
    <script src="https://cdn.jsdelivr.net/npm/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/http/web/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval/dist/umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openpgp@5.11.1/dist/openpgp.min.js"></script>
    <title>LightningFS and Isomorphic-git POC</title>
    <style>
        .repo-container {
            border: 1px solid #ccc;
            /* Light grey border */
            border-radius: 5px;
            /* Rounded corners */
            padding: 10px;
            /* Padding inside the container */
            margin-bottom: 10px;
            /* Margin at the bottom for spacing between containers */
        }
    </style>
</head>

<body>
    <div class="container mt-5">
        <h1 class="mb-3">LightningFS and Isomorphic-git POC</h1>
        <div id="staticDisplay" class="mt-3">
            <p>Navigate to the static page <a href="admin/index.html">here</a></p>
        </div>
        <!-- Bootstrap styled buttons -->
        <!-- Div for Repository URL Input, Optional pgp key and Clone Repo Button -->
        <div id="cloneControlPanel" style="display: none;">
            <form id="repoForm" class="mb-3">
                <div class="form-row align-items-center">
                    <div class="col-auto">
                        <label for="repoUrl" class="sr-only">Repository URL</label>
                        <input type="url" class="form-control mb-2" id="repoUrl" placeholder="Enter repository URL">
                    </div>
                    <div class="col-auto">
                        <button type="submit" class="btn btn-primary mb-2">Clone Repo</button>
                    </div>
                </div>
                <!-- Div for the pgp key form entry -->
                <div class="form-row align-items-center">
                    <div class="col-auto">
                        <label for="pgpKeyUrl" class="sr-only">PGP Key URL</label>
                        <input type="url" class="form-control mb-2" id="pgpKeyUrl" placeholder="Enter PGP Key URL">
                    </div>
                </div>
            </form>
        </div>
        <!-- Div for Displaying Error Messages: Empty URLs or various cloning and repo verification errors -->
        <div id="displayError" class="alert alert-warning" role="alert" style="display: none;"></div>
        <!-- Div for Delete All Repos Button -->
        <div id="deleteAllRepos" style="display: none;">
            <button id="deleteAllButton" class="btn btn-danger">Delete All Repos</button>
        </div>
        <!-- Combined Div for Delete Button and Content Display -->
        <div id="reposContainer" class="mt-3"></div>
    </div>
    <script>
        // Register the service worker
        registerServiceWorker();

        const contentDisplayId = 'contentDisplay'; // Correctly assigning the ID as a string
        const corsProxy = 'https://sandstonemountain.com'; // CORS Proxy URL

        // Instantiate a new filesystem
        const fs = new LightningFS('testfs');
        const pfs = fs.promises; // Use promises interface for cleaner async operations

        // Function to check and return content for all directories under /
        async function checkContent() {
            try {
                const rootDirEntries = await pfs.readdir('/');
                const dirStatPromises = rootDirEntries.map(async entry => {
                    const stats = await pfs.stat(`/${entry}`);
                    return { entry, isDirectory: stats.isDirectory() };
                });
                const dirStats = await Promise.all(dirStatPromises);
                const directories = dirStats.filter(({ isDirectory }) => isDirectory).map(({ entry }) => entry);
                console.log(directories);

                return directories;
            } catch (err) {
                console.log('Error reading directories:', err);
                return [];
            }
        }

        // Function to delete all repos
        async function deleteAllRepos() {
            const rootDirEntries = await pfs.readdir('/');
            for (const entry of rootDirEntries) {
                const stats = await pfs.stat(`/${entry}`);
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(`/${entry}`);
                    await pfs.rmdir(`/${entry}`);
                }
            }
        }

        // Function to recursively delete all files and directories within a given path
        async function deleteDirectoryContents(path) {
            const entries = await pfs.readdir(path);
            await Promise.all(entries.map(async (entry) => {
                const fullPath = `${path}/${entry}`;
                const stats = await pfs.stat(fullPath);
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(fullPath); // Recurse into subdirectory
                    await pfs.rmdir(fullPath); // Remove the now-empty subdirectory
                } else {
                    await pfs.unlink(fullPath); // Delete file
                }
            }));
        }

        // Function to delete cloned directory
        async function deleteRepo(directoryPath) {
            try {
                if (directoryPath !== '/') {
                    await deleteDirectoryContents(directoryPath);
                    await pfs.rmdir(directoryPath);
                    console.log(`${directoryPath} directory deleted successfully.`);
                } else {
                    console.log('Cannot delete the root directory.');
                }
            } catch (err) {
                console.log(`Failed to delete ${directoryPath}.`, err);
            }
        }

        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => {
                        reg.addEventListener('updatefound', () => {
                            const installingWorker = reg.installing;
                            console.log('A new service worker is being installed:', installingWorker);
                        });
                        console.log('Registration succeeded. Scope is ' + reg.scope);
                    })
                    .catch(error => {
                        console.log('Registration failed with ' + error);
                    });
            } else {
                console.log('Service workers are not supported in this browser.');
            }
        }

        // Fetch pgp key from a link in the form code, this will be used to verify the signature
        async function fetchPgpKey(pgpKeyUrl) {
            try {
                const response = await fetch(pgpKeyUrl);
                if (!response.ok) {
                    throw new Error('Failed to fetch PGP key');
                }
                return await response.text();
            } catch (error) {
                console.error('Error fetching PGP key:', error);
                return null;
            }
        }

        // Function to clone a repo
        async function cloneRepo(repoUrl, corsProxy, pgpKeyUrl) {
            const directoryPath = `/${repoUrl.split('/').pop().replace(/\.git$/, '')}`;

            try {
                const dirExists = await pfs.stat(directoryPath);
                console.log(`${directoryPath} exists. Deleting old contents.`);
                await deleteDirectoryContents(directoryPath);
                await pfs.rmdir(directoryPath);
                console.log("Old directory contents were overwritten.");
            } catch (error) {
                if (error.code !== 'ENOENT') {
                    console.error("Error checking directory existence:", error);
                    throw new Error(`Error checking directory existence: ${error.message}`);
                } else {
                    console.log("Directory does not exist, no need to delete.");
                }
            }

            try {
                await git.clone({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    depth: undefined, // Clone entire history
                });

                // Fetch all branches
                await git.fetch({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    tags: true,
                });

                // List all branches and filter out HEAD
                let branches = await git.listBranches({
                    fs,
                    dir: directoryPath,
                    remote: 'origin'
                });
                branches = branches.filter(branch => branch !== 'HEAD');

                for (const branch of branches) {
                    console.log(`Checking out branch: ${branch}`);
                    await git.checkout({
                        fs,
                        dir: directoryPath,
                        ref: branch,
                    });

                    const commits = await git.log({
                        fs,
                        dir: directoryPath,
                        ref: branch,
                    });

                    for (const commit of commits) {
                        const data = commit.payload;
                        const armoredSignature = commit.commit.gpgsig;
                        let armoredPublicKey = null; // Initialize the armored public key to null

                        if (!armoredSignature) {
                            await deleteDirectoryContents(directoryPath);
                            await pfs.rmdir(directoryPath);
                            console.log(`No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`);
                            displayErrorMessage(`No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`);
                            return;
                        }

                        if (pgpKeyUrl) {
                            armoredPublicKey = await fetchPgpKey(pgpKeyUrl); // Fetch the PGP key from the URL
                        }

                        if (armoredPublicKey) {
                            const isValid = await verifySignature(data, armoredSignature, armoredPublicKey);
                            if (isValid) {
                                console.log(`Signature for commit ${commit.oid} in branch ${branch} is valid.`);
                            } else {
                                await deleteDirectoryContents(directoryPath);
                                await pfs.rmdir(directoryPath);
                                console.log(`The signature for commit ${commit.oid} in branch ${branch} is invalid or does not match the provided public key. The repository has been removed.`);
                                displayErrorMessage(`The signature for commit ${commit.oid} in branch ${branch} is invalid or does not match the provided public key. The repository has been removed.`);
                                return;
                            }
                        } else {
                            await deleteDirectoryContents(directoryPath);
                            await pfs.rmdir(directoryPath);
                            console.log(`No valid PGP key provided. Repository was unverified and was deleted.`);
                            displayErrorMessage(`No valid PGP key provided. Repository was unverified and was deleted.`);
                            return;
                        }
                    }
                }

                console.log('All commits in all branches have been verified successfully.');

                return { directoryPath, branches }; // Return relevant data for rendering

            } catch (error) {
                console.error("Cloning failed:", error);
                if (error.message.includes('No signature found')) {
                    console.error(`Descriptive message: ${error.message}`);
                }
                if (error.message.includes('ENOENT')) {
                    error.message = 'An error occurred while trying to delete a non-existent directory.';
                }
                throw new Error(`Cloning failed for the following reasons: ${error.message}`);
            }
        }

        // Display the cloning error message in the UI
        function displayErrorMessage(message) {
            const errorDiv = document.getElementById('displayError');
            errorDiv.innerHTML = message;
            errorDiv.style.display = 'block';
        }

        // Function to verify the signature of the last repo commit using OpenPGP.js
        async function verifySignature(data, armoredSignature, armoredPublicKey) {
            const publicKey = await openpgp.readKey({ armoredKey: armoredPublicKey });
            const signature = await openpgp.readSignature({ armoredSignature });
            const message = await openpgp.createMessage({ text: data });

            try {
                const verificationResult = await openpgp.verify({
                    message,
                    signature,
                    verificationKeys: publicKey
                });
                const { verified, keyID } = verificationResult.signatures[0];
                await verified; // This will reject if the signature is invalid
                console.log(`Signature verified successfully with key ID ${keyID.toHex()}`);
                return true;
            } catch (e) {
                console.error(`Signature verification failed: ${e}`);
                return false;
            }
        }

        // Function to update commit dropdown
        async function updateCommitDropdown(directoryPath, branch, commitSelect) {
            try {
                console.log(`Updating commit dropdown for branch: ${branch}`);
                const commits = await git.log({
                    fs,
                    dir: directoryPath,
                    ref: branch,
                });

                commitSelect.innerHTML = ''; // Clear existing options

                if (commits.length === 0) {
                    console.log(`No commits found for branch: ${branch}`);
                } else {
                    console.log(`Found ${commits.length} commits for branch: ${branch}`);
                }

                for (const commit of commits) {
                    console.log(`Adding commit: ${commit.oid}, message: ${commit.commit.message}`);
                    const commitOption = document.createElement('option');
                    commitOption.value = commit.oid;
                    commitOption.textContent = commit.commit.message ? commit.commit.message : commit.oid;
                    commitSelect.appendChild(commitOption);
                }
            } catch (error) {
                console.error('Error updating commit dropdown:', error);
            }
        }

        // Function to checkout a specific commit
        async function checkoutCommit(directoryPath, branch, commit) {
            try {
                console.log(`Checking out commit: ${commit} in branch: ${branch}`);
                await git.checkout({
                    fs,
                    dir: directoryPath,
                    ref: commit,
                    force: true,
                });
                console.log(`Checked out commit ${commit} in branch ${branch}`);
            } catch (error) {
                console.error(`Error checking out commit ${commit} in branch ${branch}:`, error);
            }
        }

        // Function to render the repos and related UI elements
        async function renderRepos() {
            const directories = await checkContent();
            const reposContainer = document.getElementById('reposContainer');
            reposContainer.innerHTML = ''; // Clear existing content

            const cloneControlPanel = document.getElementById('cloneControlPanel');
            cloneControlPanel.style.display = 'block'; // Always show the cloneControlPanel

            if (directories.length > 0) {
                for (const dir of directories) {
                    let directoryPath = `/${dir}`;
                    const dirEntries = await pfs.readdir(directoryPath);

                    if (dirEntries.length > 0) {
                        const repoContainer = document.createElement('div');
                        repoContainer.classList.add('repo-container', 'mb-3');
                        reposContainer.appendChild(repoContainer);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.textContent = 'Delete Repo';
                        deleteBtn.classList.add('btn', 'btn-danger', 'mb-2');
                        deleteBtn.addEventListener('click', async () => {
                            await deleteRepo(directoryPath);
                            renderRepos();
                        });
                        repoContainer.appendChild(deleteBtn);

                        const contentDisplay = document.createElement('div');
                        if (dirEntries.includes('index.html')) {
                            contentDisplay.innerHTML = `<h3>${dir}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                        } else {
                            contentDisplay.innerHTML = `<h3>${dir}</h3>No index.html found in this directory.<br>`;
                        }
                        repoContainer.appendChild(contentDisplay);

                        const branchSelect = document.createElement('select');
                        branchSelect.classList.add('form-control', 'mb-2');
                        repoContainer.appendChild(branchSelect);

                        // Get the current branch
                        const currentBranch = await git.currentBranch({ fs, dir: directoryPath, fullname: false });

                        let branches = await git.listBranches({
                            fs,
                            dir: directoryPath,
                            remote: 'origin'
                        });
                        branches = branches.filter(branch => branch !== 'HEAD');

                        for (const branch of branches) {
                            const branchOption = document.createElement('option');
                            branchOption.value = branch;
                            branchOption.textContent = branch;
                            if (branch === currentBranch) {
                                branchOption.selected = true;
                            }
                            branchSelect.appendChild(branchOption);
                        }

                        const commitSelect = document.createElement('select');
                        commitSelect.classList.add('form-control', 'mb-2');
                        repoContainer.appendChild(commitSelect);

                        branchSelect.addEventListener('change', async (event) => {
                            await updateCommitDropdown(directoryPath, branchSelect.value, commitSelect);
                        });

                        commitSelect.addEventListener('change', async (event) => {
                            await checkoutCommit(directoryPath, branchSelect.value, commitSelect.value);
                            const dirEntries = await pfs.readdir(directoryPath);
                            if (dirEntries.includes('index.html')) {
                                contentDisplay.innerHTML = `<h3>${dir}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                            } else {
                                contentDisplay.innerHTML = `<h3>${dir}</h3>No index.html found in this directory.<br>`;
                            }
                        });

                        // Get the current commit
                        const currentCommit = await git.resolveRef({ fs, dir: directoryPath, ref: 'HEAD' });
                        await updateCommitDropdown(directoryPath, branchSelect.value, commitSelect);
                        commitSelect.value = currentCommit;

                        reposContainer.appendChild(repoContainer);
                    }
                }
                document.getElementById('deleteAllRepos').style.display = 'block'; // Show the deleteAllRepos button
            } else { // Hide the deleteAllRepos button if there are no directories
                document.getElementById('deleteAllRepos').style.display = 'none';
            }
            // Call the function to list all directory contents
            listAllDirectoryContents();
        }

        //debug function to list all directory contents for cloned repositories
        async function listAllDirectoryContents() {
            try {
                const rootDirEntries = await pfs.readdir('/');
                for (const entry of rootDirEntries) {
                    const stats = await pfs.stat(`/${entry}`);
                    if (stats.isDirectory()) {
                        const dirPath = `/${entry}`;
                        const dirContents = await pfs.readdir(dirPath);
                        console.log(`Contents of ${dirPath}:`, dirContents);
                    }
                }
            } catch (err) {
                console.error('Error listing directory contents:', err);
            }
        }

        // Attach the event listeners to the buttons
        document.getElementById('repoForm').addEventListener('submit', async function (event) {
            event.preventDefault();
            const repoUrl = document.getElementById('repoUrl').value;
            const pgpKeyUrl = document.getElementById('pgpKeyUrl').value;
            if (repoUrl && pgpKeyUrl) {
                document.getElementById('displayError').style.display = 'none';
                try {
                    await cloneRepo(repoUrl, corsProxy, pgpKeyUrl);
                    renderRepos();
                } catch (error) {
                    displayErrorMessage(error.message);
                }
            } else {
                displayErrorMessage('Please fill in both the repository and the PGP Key URLs.');
            }
        });

        // Attach the event listener to the delete all repos button
        document.getElementById('deleteAllButton').addEventListener('click', async () => {
            await deleteAllRepos();
            renderRepos();
        });

        // Perform an initial check to set up the UI appropriately based on the current state
        renderRepos();

    </script>
</body>

</html>