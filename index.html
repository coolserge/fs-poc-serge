<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
        integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <title>LightningFS and Isomorphic-git POC</title>
    <style>
        .repo-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="mb-3">LightningFS and Isomorphic-git POC</h1>
        <div id="staticDisplay" class="mt-3">
            <p>Navigate to the static page <a href="admin/index.html">here</a></p>
        </div>
        <div id="cloneControlPanel" class="mb-3" style="display: none;">
            <form id="repoForm">
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <label for="repoUrl" class="sr-only">Repository URL</label>
                        <input type="url" class="form-control mb-2" id="repoUrl" placeholder="Enter repository URL" required>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <label for="pgpKeyUrl" class="sr-only">PGP Key URL</label>
                        <input type="url" class="form-control mb-2" id="pgpKeyUrl" placeholder="Enter PGP Key URL" required>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <button type="submit" class="btn btn-primary mb-2">Clone Repo</button>
                    </div>
                </div>
            </form>
        </div>
        <div id="displayError" class="alert alert-warning" role="alert" style="display: none;"></div>
        <div id="reposContainer" class="mt-3"></div>
        <div id="deleteAllRepos" class="mt-3 mb-3" style="display: none;">
            <button id="deleteAllButton" class="btn btn-danger">Delete All Repos</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/http/web/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval/dist/umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openpgp@5.11.1/dist/openpgp.min.js"></script>

    <script>
    // Utility functions
    const fs = new LightningFS('testfs');
    const pfs = fs.promises;
    const corsProxy = 'https://sandstoremountain.com';
    const errorDiv = document.getElementById('displayError');

    async function checkContent() {
        try {
            const rootDirEntries = await pfs.readdir('/');
            const dirStats = await Promise.all(rootDirEntries.map(async entry => {
                const stats = await pfs.stat(`/${entry}`);
                return { entry, isDirectory: stats.isDirectory() };
            }));
            return dirStats.filter(({ isDirectory }) => isDirectory).map(({ entry }) => entry);
        } catch (err) {
            console.log('Error reading directories:', err);
            return [];
        }
    }

    async function deleteDirectoryContents(path) {
        const entries = await pfs.readdir(path);
        await Promise.all(entries.map(async entry => {
            const fullPath = `${path}/${entry}`;
            const stats = await pfs.stat(fullPath);
            if (stats.isDirectory()) {
                await deleteDirectoryContents(fullPath);
                await pfs.rmdir(fullPath);
            } else {
                await pfs.unlink(fullPath);
            }
        }));
    }

    function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => {
                    reg.addEventListener('updatefound', () => {
                        const installingWorker = reg.installing;
                        console.log('A new service worker is being installed:', installingWorker);
                    });
                    console.log('Registration succeeded. Scope is ' + reg.scope);
                })
                .catch(error => {
                    console.log('Registration failed with ' + error);
                });
        } else {
            console.log('Service workers are not supported in this browser.');
        }
    }

    async function fetchPgpKey(pgpKeyUrl) {
        try {
            const response = await fetch(pgpKeyUrl);
            if (!response.ok) {
                throw new Error('Failed to fetch PGP key');
            }
            return await response.text();
        } catch (error) {
            console.error('Error fetching PGP key:', error);
            return null;
        }
    }

    async function verifySignature(data, armoredSignature, armoredPublicKey) {
        const publicKey = await openpgp.readKey({ armoredKey: armoredPublicKey });
        const signature = await openpgp.readSignature({ armoredSignature });
        const message = await openpgp.createMessage({ text: data });

        try {
            const verificationResult = await openpgp.verify({
                message,
                signature,
                verificationKeys: publicKey
            });
            const { verified, keyID } = verificationResult.signatures[0];
            await verified;
            console.log(`Signature verified successfully with key ID ${keyID.toHex()}`);
            return true;
        } catch (e) {
            console.error(`Signature verification failed: ${e}`);
            return false;
        }
    }

    // Git operations module
    const gitOps = {
        async cloneRepo(repoUrl, pgpKeyUrl) {
            const directoryPath = `/${repoUrl.split('/').pop().replace(/\.git$/, '')}`;

            try {
                const dirExists = await pfs.stat(directoryPath);
                await deleteDirectoryContents(directoryPath);
                await pfs.rmdir(directoryPath);
            } catch (error) {
                if (error.code !== 'ENOENT') {
                    console.error("Error checking directory existence:", error);
                    throw new Error(`Error checking directory existence: ${error.message}`);
                }
            }

            try {
                await git.clone({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    depth: undefined,
                });

                await git.fetch({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    tags: true,
                });

                let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' });
                branches = branches.filter(branch => branch !== 'HEAD');

                for (const branch of branches) {
                    await git.checkout({ fs, dir: directoryPath, ref: branch });
                    const commits = await git.log({ fs, dir: directoryPath, ref: branch });

                    for (const commit of commits) {
                        const data = commit.payload;
                        const armoredSignature = commit.commit.gpgsig;
                        if (!armoredSignature) {
                            await deleteDirectoryContents(directoryPath);
                            await pfs.rmdir(directoryPath);
                            throw new Error(`No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`);
                        }

                        const armoredPublicKey = await fetchPgpKey(pgpKeyUrl);
                        if (armoredPublicKey && await verifySignature(data, armoredSignature, armoredPublicKey)) {
                            console.log(`Signature for commit ${commit.oid} in branch ${branch} is valid.`);
                        } else {
                            await deleteDirectoryContents(directoryPath);
                            await pfs.rmdir(directoryPath);
                            throw new Error(`The signature for commit ${commit.oid} in branch ${branch} is invalid. Repository has been removed.`);
                        }
                    }
                }

                return { success: true, directoryPath, branches };
            } catch (error) {
                console.error("Cloning failed:", error);
                return { success: false, message: error.message };
            }
        },

        async getCurrentBranchAndCommit(directoryPath) {
            try {
                const headContent = await pfs.readFile(`${directoryPath}/.git/HEAD`, { encoding: 'utf8' });
                const trimmedContent = headContent.trim();

                if (trimmedContent.startsWith('ref: refs/heads/')) {
                    const branch = trimmedContent.replace('ref: refs/heads/', '');
                    const commit = await git.resolveRef({ fs, dir: directoryPath, ref: branch });
                    return { branch, commit };
                } else {
                    return { branch: null, commit: trimmedContent };
                }
            } catch (error) {
                console.error('Error getting current branch and commit:', error);
                return { branch: null, commit: null };
            }
        },

        async listBranches(directoryPath) {
            try {
                let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' });
                return branches.filter(branch => branch !== 'HEAD');
            } catch (error) {
                console.error('Error listing branches:', error);
                return [];
            }
        },

        async getCommitsForBranch(directoryPath, branch) {
            try {
                return await git.log({ fs, dir: directoryPath, ref: branch });
            } catch (error) {
                console.error(`Error getting commits for branch ${branch}:`, error);
                return [];
            }
        },

        async checkoutCommit(directoryPath, branch, commit) {
            try {
                await git.checkout({ fs, dir: directoryPath, ref: branch });
                if (commit) {
                    await git.checkout({ fs, dir: directoryPath, ref: commit });
                }
                console.log(`Checked out commit ${commit} in branch ${branch}`);
            } catch (error) {
                console.error(`Error checking out commit ${commit} in branch ${branch}:`, error);
            }
        },

        async deleteRepo(directoryPath) {
            try {
                if (directoryPath !== '/') {
                    await deleteDirectoryContents(directoryPath);
                    await pfs.rmdir(directoryPath);
                    console.log(`${directoryPath} directory deleted successfully.`);
                } else {
                    console.log('Cannot delete the root directory.');
                }
            } catch (err) {
                console.log(`Failed to delete ${directoryPath}.`, err);
            }
        },

        async deleteAllRepos() {
            const rootDirEntries = await pfs.readdir('/');
            for (const entry of rootDirEntries) {
                const stats = await pfs.stat(`/${entry}`);
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(`/${entry}`);
                    await pfs.rmdir(`/${entry}`);
                }
            }
        }
    };

    // UI rendering module
    const renderUI = {
    async renderRepos() {
        const directories = await checkContent();
        const reposContainer = document.getElementById('reposContainer');
        reposContainer.innerHTML = '';

        const cloneControlPanel = document.getElementById('cloneControlPanel');
        cloneControlPanel.style.display = 'block';

        if (directories.length > 0) {
            for (const dir of directories) {
                const directoryPath = `/${dir}`;
                const dirEntries = await pfs.readdir(directoryPath);

                if (dirEntries.length > 0) {
                    const repoContainer = this.createRepoContainer(dir, directoryPath);
                    const { branchSelect, commitSelect } = this.createSelects(repoContainer);

                    const { branch: currentBranch, commit: currentCommit } = await gitOps.getCurrentBranchAndCommit(directoryPath);
                    
                    await this.populateBranchSelect(directoryPath, branchSelect, currentBranch);
                    await this.populateCommitSelect(directoryPath, commitSelect, currentBranch || branchSelect.value, currentCommit);

                    this.setupEventListeners(directoryPath, branchSelect, commitSelect);
                    reposContainer.appendChild(repoContainer);

                    await this.updateContentDisplay(directoryPath);
                }
            }
            document.getElementById('deleteAllRepos').style.display = 'block';
        } else {
            document.getElementById('deleteAllRepos').style.display = 'none';
        }
    },

    createRepoContainer(dir, directoryPath) {
        const repoContainer = document.createElement('div');
        repoContainer.classList.add('repo-container', 'mb-3');

        const contentDisplay = document.createElement('div');
        contentDisplay.dataset.directory = directoryPath;
        contentDisplay.innerHTML = `<h3>${dir}</h3>`;
        repoContainer.appendChild(contentDisplay);

        return repoContainer;
    },

    createSelects(repoContainer) {
        const branchSelect = document.createElement('select');
        branchSelect.classList.add('form-control', 'mb-2');
        repoContainer.appendChild(branchSelect);

        const commitSelect = document.createElement('select');
        commitSelect.classList.add('form-control', 'mb-2');
        repoContainer.appendChild(commitSelect);

        return { branchSelect, commitSelect };
    },

    async populateBranchSelect(directoryPath, branchSelect, currentBranch) {
        const branches = await gitOps.listBranches(directoryPath);
        branchSelect.innerHTML = '';
        for (const branch of branches) {
            const branchOption = document.createElement('option');
            branchOption.value = branch;
            branchOption.textContent = branch;
            if (branch === currentBranch) {
                branchOption.selected = true;
            }
            branchSelect.appendChild(branchOption);
        }
    },

    async populateCommitSelect(directoryPath, commitSelect, branch, currentCommit) {
        const commits = await gitOps.getCommitsForBranch(directoryPath, branch);
        commitSelect.innerHTML = '';
        for (const commit of commits) {
            const commitOption = document.createElement('option');
            commitOption.value = commit.oid;
            commitOption.textContent = `${commit.oid.slice(0, 7)} - ${commit.commit.message.split('\n')[0]}`;
            if (commit.oid === currentCommit) {
                commitOption.selected = true;
            }
            commitSelect.appendChild(commitOption);
        }
    },

    setupEventListeners(directoryPath, branchSelect, commitSelect) {
        branchSelect.addEventListener('change', async () => {
            await this.populateCommitSelect(directoryPath, commitSelect, branchSelect.value);
        });

        commitSelect.addEventListener('change', async () => {
            await gitOps.checkoutCommit(directoryPath, branchSelect.value, commitSelect.value);
            await this.updateContentDisplay(directoryPath);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete Repo';
        deleteBtn.classList.add('btn', 'btn-danger', 'mb-2');
        deleteBtn.addEventListener('click', async () => {
            await gitOps.deleteRepo(directoryPath);
            await this.renderRepos();
        });
        branchSelect.parentNode.appendChild(deleteBtn);
    },

    async updateContentDisplay(directoryPath) {
        const dirEntries = await pfs.readdir(directoryPath);
        const contentDisplay = document.querySelector(`[data-directory="${directoryPath}"]`);
        if (contentDisplay) {
            const repoName = directoryPath.slice(1);
            if (dirEntries.includes('index.html')) {
                contentDisplay.innerHTML = `<h3>${repoName}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
            } else {
                contentDisplay.innerHTML = `<h3>${repoName}</h3>No index.html found in this directory.<br>`;
            }
        }
    },

    displayErrorMessage(message) {
        errorDiv.innerHTML = message;
        errorDiv.style.display = message ? 'block' : 'none';
    }
};

    // Main script
    document.getElementById('repoForm').addEventListener('submit', async function (event) {
        event.preventDefault();
        const repoUrl = document.getElementById('repoUrl').value;
        const pgpKeyUrl = document.getElementById('pgpKeyUrl').value;
        if (repoUrl && pgpKeyUrl) {
            renderUI.displayErrorMessage('');
            const result = await gitOps.cloneRepo(repoUrl, pgpKeyUrl);
            if (result.success) {
                await renderUI.renderRepos();
            } else {
                renderUI.displayErrorMessage(result.message);
            }
        } else {
            renderUI.displayErrorMessage('Please fill in both the repository and the PGP Key URLs.');
        }
    });

    document.getElementById('deleteAllButton').addEventListener('click', async () => {
        await gitOps.deleteAllRepos();
        await renderUI.renderRepos();
    });

    // Initialize
    registerServiceWorker();
    renderUI.renderRepos();
    </script>
</body>
</html>