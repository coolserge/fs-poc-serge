<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS CDN for responsive design and styling -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
        integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <title>LightningFS and Isomorphic-git POC</title>
    <style>
        .repo-container {
            border: 1px solid #ccc;
            /* Light grey border */
            border-radius: 5px;
            /* Rounded corners */
            padding: 10px;
            /* Padding inside the container */
            margin-bottom: 10px;
            /* Margin at the bottom for spacing between containers */
        }
    </style>
</head>

<body>
    <div class="container mt-5">
        <h1 class="mb-3">LightningFS and Isomorphic-git POC</h1>
        <div id="staticDisplay" class="mt-3">
            <p>Navigate to the static page <a href="admin/index.html">here</a></p>
        </div>
        <!-- Clone control panel for inputting repo URL and PGP key URL -->
        <div id="cloneControlPanel" class="mb-3" style="display: none;">
            <form id="repoForm">
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <label for="repoUrl" class="sr-only">Repository URL</label>
                        <input type="url" class="form-control mb-2" id="repoUrl" placeholder="Enter repository URL"
                            required>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <label for="pgpKeyUrl" class="sr-only">PGP Key URL</label>
                        <input type="url" class="form-control mb-2" id="pgpKeyUrl" placeholder="Enter PGP Key URL"
                            required>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <button type="submit" class="btn btn-primary mb-2">Clone Repo</button>
                    </div>
                </div>
            </form>
        </div>
        <!-- Error message display area -->
        <div id="displayError" class="alert alert-warning" role="alert" style="display: none;"></div>
        <!-- Container for displaying cloned repositories -->
        <div id="reposContainer" class="mt-3"></div>
        <!-- Delete all repositories button -->
        <div id="deleteAllRepos" class="mt-3 mb-3" style="display: none;">
            <button id="deleteAllButton" class="btn btn-danger">Delete All Repos</button>
        </div>
    </div>


    <!-- LightningFS and Isomorphic-git scripts for file system and git operations -->
    <script src="https://cdn.jsdelivr.net/npm/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/http/web/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval/dist/umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openpgp@5.11.1/dist/openpgp.min.js"></script>

    <script>
        // Register the service worker to enable offline capabilities
        registerServiceWorker();

        // Initialize a new filesystem using LightningFS
        const fs = new LightningFS('testfs');
        const pfs = fs.promises; // Promises interface for asynchronous operations
        const corsProxy = 'https://sandstonemountain.com'; // CORS Proxy URL
        const errorDiv = document.getElementById('displayError'); // Error display div

        // Function to check and return the list of directories in the root
        async function checkContent() {
            try {
                const rootDirEntries = await pfs.readdir('/'); // Read root directory entries
                const dirStats = await Promise.all(rootDirEntries.map(async entry => {
                    const stats = await pfs.stat(`/${entry}`); // Get stats for each entry
                    return { entry, isDirectory: stats.isDirectory() }; // Return entry name and directory status
                }));
                return dirStats.filter(({ isDirectory }) => isDirectory).map(({ entry }) => entry); // Filter and map directory entries
            } catch (err) {
                console.log('Error reading directories:', err); // Log error if reading directories fails
                return [];
            }
        }

        // Function to recursively delete contents of a directory
        async function deleteDirectoryContents(path) {
            const entries = await pfs.readdir(path); // Read directory entries
            await Promise.all(entries.map(async entry => {
                const fullPath = `${path}/${entry}`; // Construct full path
                const stats = await pfs.stat(fullPath); // Get stats for each entry
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(fullPath); // Recursively delete subdirectory contents
                    await pfs.rmdir(fullPath); // Remove the now-empty subdirectory
                } else {
                    await pfs.unlink(fullPath); // Delete file
                }
            }));
        }

        // Function to delete a repository directory
        async function deleteRepo(directoryPath) {
            try {
                if (directoryPath !== '/') {
                    await deleteDirectoryContents(directoryPath); // Delete all contents within the directory
                    await pfs.rmdir(directoryPath); // Remove the directory itself
                    console.log(`${directoryPath} directory deleted successfully.`);
                } else {
                    console.log('Cannot delete the root directory.');
                }
            } catch (err) {
                console.log(`Failed to delete ${directoryPath}.`, err); // Log error if deletion fails
            }
        }

        // Function to register the service worker
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => {
                        reg.addEventListener('updatefound', () => {
                            const installingWorker = reg.installing;
                            console.log('A new service worker is being installed:', installingWorker);
                        });
                        console.log('Registration succeeded. Scope is ' + reg.scope);
                    })
                    .catch(error => {
                        console.log('Registration failed with ' + error);
                    });
            } else {
                console.log('Service workers are not supported in this browser.');
            }
        }

        // Function to fetch PGP key from a URL
        async function fetchPgpKey(pgpKeyUrl) {
            try {
                const response = await fetch(pgpKeyUrl); // Fetch PGP key
                if (!response.ok) {
                    throw new Error('Failed to fetch PGP key'); // Throw error if response is not OK
                }
                return await response.text(); // Return PGP key text
            } catch (error) {
                console.error('Error fetching PGP key:', error); // Log error if fetching fails
                return null;
            }
        }

        // Function to clone a repository
        async function cloneRepo(repoUrl, pgpKeyUrl) {
            const directoryPath = `/${repoUrl.split('/').pop().replace(/\.git$/, '')}`; // Construct directory path from repo URL

            try {
                const dirExists = await pfs.stat(directoryPath); // Check if directory exists
                await deleteDirectoryContents(directoryPath); // Delete existing contents if directory exists
                await pfs.rmdir(directoryPath); // Remove the directory
            } catch (error) {
                if (error.code !== 'ENOENT') {
                    console.error("Error checking directory existence:", error); // Log error if not ENOENT
                    throw new Error(`Error checking directory existence: ${error.message}`);
                }
            }

            try {
                // Clone the repository
                await git.clone({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    depth: undefined,
                });

                // Fetch all branches and tags
                await git.fetch({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    tags: true,
                });

                // List all branches and filter out HEAD
                let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' });
                branches = branches.filter(branch => branch !== 'HEAD');

                for (const branch of branches) {
                    await git.checkout({ fs, dir: directoryPath, ref: branch }); // Checkout each branch
                    const commits = await git.log({ fs, dir: directoryPath, ref: branch }); // Get commit log

                    for (const commit of commits) {
                        const data = commit.payload;
                        const armoredSignature = commit.commit.gpgsig;
                        if (!armoredSignature) {
                            await deleteDirectoryContents(directoryPath); // Delete contents if no signature
                            await pfs.rmdir(directoryPath);
                            throw new Error(`No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`);
                        }

                        const armoredPublicKey = await fetchPgpKey(pgpKeyUrl); // Fetch PGP key
                        if (armoredPublicKey && await verifySignature(data, armoredSignature, armoredPublicKey)) {
                            console.log(`Signature for commit ${commit.oid} in branch ${branch} is valid.`);
                        } else {
                            await deleteDirectoryContents(directoryPath); // Delete contents if signature invalid
                            await pfs.rmdir(directoryPath);
                            throw new Error(`The signature for commit ${commit.oid} in branch ${branch} is invalid. Repository has been removed.`);
                        }
                    }
                }

                return { success: true, directoryPath, branches }; // Return relevant data for rendering
            } catch (error) {
                console.error("Cloning failed:", error); // Log error if cloning fails
                return { success: false, message: error.message };
            }
        }

        // Display the cloning error message in the UI
        function displayErrorMessage(message) {
            errorDiv.innerHTML = message; // Set the error message
            errorDiv.style.display = 'block'; // Display the error message div
        }

        // Function to verify the signature of a commit using OpenPGP.js
        async function verifySignature(data, armoredSignature, armoredPublicKey) {
            const publicKey = await openpgp.readKey({ armoredKey: armoredPublicKey }); // Read PGP public key
            const signature = await openpgp.readSignature({ armoredSignature }); // Read PGP signature
            const message = await openpgp.createMessage({ text: data }); // Create a message from the commit data

            try {
                const verificationResult = await openpgp.verify({
                    message,
                    signature,
                    verificationKeys: publicKey
                });
                const { verified, keyID } = verificationResult.signatures[0];
                await verified; // Await the verification result
                console.log(`Signature verified successfully with key ID ${keyID.toHex()}`);
                return true;
            } catch (e) {
                console.error(`Signature verification failed: ${e}`);
                return false;
            }
        }

        // Function to update commit dropdown with commits from a branch
        async function updateCommitDropdown(directoryPath, branch, commitSelect) {
            try {
                console.log(`Updating commit dropdown for branch: ${branch}`);
                const commits = await git.log({ fs, dir: directoryPath, ref: branch }); // Get commits for branch

                commitSelect.innerHTML = ''; // Clear existing options

                if (commits.length === 0) {
                    console.log(`No commits found for branch: ${branch}`);
                } else {
                    console.log(`Found ${commits.length} commits for branch: ${branch}`);
                }

                for (const commit of commits) {
                    console.log(`Adding commit: ${commit.oid}, message: ${commit.commit.message}`);
                    const commitOption = document.createElement('option'); // Create option element for each commit
                    commitOption.value = commit.oid; // Set commit OID as value
                    commitOption.textContent = commit.commit.message ? commit.commit.message : commit.oid; // Set commit message or OID as text
                    commitSelect.appendChild(commitOption); // Append option to select element
                }
            } catch (error) {
                console.error('Error updating commit dropdown:', error);
            }
        }

        // Function to checkout a specific commit
        async function checkoutCommit(directoryPath, branch, commit) {
            try {
                console.log(`Checking out commit: ${commit} in branch: ${branch}`);
                await git.checkout({ fs, dir: directoryPath, ref: commit, force: true }); // Checkout the specific commit
                console.log(`Checked out commit ${commit} in branch ${branch}`);
            } catch (error) {
                console.error(`Error checking out commit ${commit} in branch ${branch}:`, error);
            }
        }

        // Function to render the repositories and related UI elements
        async function renderRepos() {
            const directories = await checkContent(); // Get list of directories
            const reposContainer = document.getElementById('reposContainer'); // Repositories container div
            reposContainer.innerHTML = ''; // Clear existing content

            const cloneControlPanel = document.getElementById('cloneControlPanel'); // Clone control panel div
            cloneControlPanel.style.display = 'block'; // Show clone control panel

            if (directories.length > 0) {
                for (const dir of directories) {
                    let directoryPath = `/${dir}`;
                    const dirEntries = await pfs.readdir(directoryPath); // Read directory entries

                    if (dirEntries.length > 0) {
                        const repoContainer = document.createElement('div'); // Create container for each repository
                        repoContainer.classList.add('repo-container', 'mb-3'); // Add Bootstrap classes
                        reposContainer.appendChild(repoContainer); // Append repository container to main container

                        const deleteBtn = document.createElement('button'); // Create delete button
                        deleteBtn.textContent = 'Delete Repo'; // Set button text
                        deleteBtn.classList.add('btn', 'btn-danger', 'mb-2'); // Add Bootstrap classes
                        deleteBtn.addEventListener('click', async () => {
                            await deleteRepo(directoryPath); // Delete repository on button click
                            renderRepos(); // Re-render repositories
                        });
                        repoContainer.appendChild(deleteBtn); // Append delete button to repository container

                        const contentDisplay = document.createElement('div'); // Create content display div
                        if (dirEntries.includes('index.html')) {
                            contentDisplay.innerHTML = `<h3>${dir}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                        } else {
                            contentDisplay.innerHTML = `<h3>${dir}</h3>No index.html found in this directory.<br>`;
                        }
                        repoContainer.appendChild(contentDisplay); // Append content display to repository container

                        const branchSelect = document.createElement('select'); // Create branch select element
                        branchSelect.classList.add('form-control', 'mb-2'); // Add Bootstrap classes
                        repoContainer.appendChild(branchSelect); // Append branch select to repository container

                        const currentBranch = await git.currentBranch({ fs, dir: directoryPath, fullname: false }); // Get current branch

                        let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' }); // List branches
                        branches = branches.filter(branch => branch !== 'HEAD'); // Filter out HEAD

                        for (const branch of branches) {
                            const branchOption = document.createElement('option'); // Create option element for each branch
                            branchOption.value = branch; // Set branch name as value
                            branchOption.textContent = branch; // Set branch name as text
                            if (branch === currentBranch) {
                                branchOption.selected = true; // Mark current branch as selected
                            }
                            branchSelect.appendChild(branchOption); // Append option to select element
                        }

                        const commitSelect = document.createElement('select'); // Create commit select element
                        commitSelect.classList.add('form-control', 'mb-2'); // Add Bootstrap classes
                        repoContainer.appendChild(commitSelect); // Append commit select to repository container

                        // Update commit dropdown when branch is changed
                        branchSelect.addEventListener('change', async (event) => {
                            await updateCommitDropdown(directoryPath, branchSelect.value, commitSelect);
                        });

                        // Checkout commit when commit is changed
                        commitSelect.addEventListener('change', async (event) => {
                            await checkoutCommit(directoryPath, branchSelect.value, commitSelect.value);
                            const dirEntries = await pfs.readdir(directoryPath); // Read updated directory entries
                            if (dirEntries.includes('index.html')) {
                                contentDisplay.innerHTML = `<h3>${dir}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                            } else {
                                contentDisplay.innerHTML = `<h3>${dir}</h3>No index.html found in this directory.<br>`;
                            }
                        });

                        const currentCommit = await git.resolveRef({ fs, dir: directoryPath, ref: 'HEAD' }); // Get current commit
                        await updateCommitDropdown(directoryPath, branchSelect.value, commitSelect); // Update commit dropdown
                        commitSelect.value = currentCommit; // Set current commit as selected

                        reposContainer.appendChild(repoContainer); // Append repository container to main container
                    }
                }
                document.getElementById('deleteAllRepos').style.display = 'block'; // Show delete all repos button
            } else {
                document.getElementById('deleteAllRepos').style.display = 'none'; // Hide delete all repos button if no directories
            }

            // Call the function to list all directory contents
            listAllDirectoryContents();
        }

        // Function to delete all repositories
        async function deleteAllRepos() {
            const rootDirEntries = await pfs.readdir('/'); // Read root directory entries
            for (const entry of rootDirEntries) {
                const stats = await pfs.stat(`/${entry}`); // Get stats for each entry
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(`/${entry}`); // Recursively delete directory contents
                    await pfs.rmdir(`/${entry}`); // Remove directory
                }
            }
        }

        // Debug function to list all directory contents for cloned repositories
        async function listAllDirectoryContents() {
            try {
                const rootDirEntries = await pfs.readdir('/');
                for (const entry of rootDirEntries) {
                    const stats = await pfs.stat(`/${entry}`);
                    if (stats.isDirectory()) {
                        const dirPath = `/${entry}`;
                        const dirContents = await pfs.readdir(dirPath);
                        console.log(`Contents of ${dirPath}:`, dirContents);
                    }
                }
            } catch (err) {
                console.error('Error listing directory contents:', err);
            }
        }

        // Attach event listener to repository form for cloning
        document.getElementById('repoForm').addEventListener('submit', async function (event) {
            event.preventDefault(); // Prevent default form submission
            const repoUrl = document.getElementById('repoUrl').value; // Get repository URL
            const pgpKeyUrl = document.getElementById('pgpKeyUrl').value; // Get PGP key URL
            if (repoUrl && pgpKeyUrl) {
                errorDiv.style.display = 'none'; // Hide error message div
                const result = await cloneRepo(repoUrl, pgpKeyUrl); // Clone repository
                if (result.success) {
                    renderRepos(); // Re-render repositories on success
                } else {
                    displayErrorMessage(result.message); // Display error message if cloning fails
                }
            } else {
                displayErrorMessage('Please fill in both the repository and the PGP Key URLs.'); // Display error if fields are empty
            }
        });

        // Attach event listener to delete all repositories button
        document.getElementById('deleteAllButton').addEventListener('click', async () => {
            await deleteAllRepos(); // Delete all repositories on button click
            renderRepos(); // Re-render repositories
        });

        // Initial render of repositories on page load
        renderRepos();
    </script>
</body>

</html>