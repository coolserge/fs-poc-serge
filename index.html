<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
        integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/http/web/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval/dist/umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openpgp@5.11.1/dist/openpgp.min.js"></script>
    <title>LightningFS and Isomorphic-git POC</title>
    <style>
        .repo-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <div class="container mt-5">
        <h1 class="mb-3">LightningFS and Isomorphic-git POC</h1>
        <div id="staticDisplay" class="mt-3">
            <p>Navigate to the static page <a href="admin/index.html">here</a></p>
        </div>
        <div id="cloneControlPanel">
            <form id="repoForm" class="mb-3">
                <div class="form-row align-items-center">
                    <div class="col-auto">
                        <label for="repoUrl" class="sr-only">Repository URL</label>
                        <input type="url" class="form-control mb-2" id="repoUrl" placeholder="Enter repository URL">
                    </div>
                    <div class="col-auto">
                        <button type="submit" class="btn btn-primary mb-2">Clone Repo</button>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-auto">
                        <label for="pgpKeyUrl" class="sr-only">PGP Key URL</label>
                        <input type="url" class="form-control mb-2" id="pgpKeyUrl" placeholder="Enter PGP Key URL">
                    </div>
                </div>
            </form>
        </div>
        <div id="displayError" class="alert alert-warning" role="alert" style="display: none;"></div>
        <div id="deleteAllRepos">
            <button id="deleteAllButton" class="btn btn-danger">Delete All Repos</button>
        </div>
        <div id="reposContainer" class="mt-3"></div>
    </div>
    <script>
        registerServiceWorker();

        const corsProxy = 'https://sandstonemountain.com';
        const fs = new LightningFS('testfs');
        const pfs = fs.promises;

        async function checkAndDisplayContent() {
            console.log('Checking and displaying content...');
            try {
                const rootDirEntries = await pfs.readdir('/');
                console.log('Root directory entries:', rootDirEntries);

                const dirStatPromises = rootDirEntries.map(async entry => {
                    const stats = await pfs.stat(`/${entry}`);
                    return { entry, isDirectory: stats.isDirectory() };
                });
                const dirStats = await Promise.all(dirStatPromises);
                console.log('Directory stats:', dirStats);

                const directories = dirStats.filter(({ isDirectory }) => isDirectory).map(({ entry }) => entry);
                console.log('Directories:', directories);

                const repoInfo = [];

                if (directories.length > 0) {
                    for (const dir of directories) {
                        let directoryPath = `/${dir}`;
                        const dirEntries = await pfs.readdir(directoryPath);
                        console.log(`Entries in ${directoryPath}:`, dirEntries);

                        if (dirEntries.length > 0) {
                            const currentBranch = await git.currentBranch({ fs, dir: directoryPath, fullname: false });
                            console.log(`Current branch of ${directoryPath}:`, currentBranch);

                            let branches = await git.listBranches({
                                fs,
                                dir: directoryPath,
                                remote: 'origin'
                            });
                            branches = branches.filter(branch => branch !== 'HEAD');
                            console.log(`Branches in ${directoryPath}:`, branches);

                            const branchCommits = {};
                            for (const branch of branches) {
                                const commits = await git.log({ fs, dir: directoryPath, ref: branch });
                                branchCommits[branch] = commits;
                                console.log(`Commits in branch ${branch} of ${directoryPath}:`, commits);
                            }

                            repoInfo.push({
                                directory: dir,
                                branches: branches,
                                currentBranch: currentBranch,
                                branchCommits: branchCommits
                            });
                        }
                    }
                }

                console.log('Repo Information:', repoInfo);
                return repoInfo;

            } catch (err) {
                console.log('Error reading directories:', err);
                return { error: err.message };
            }
        }

        async function cloneRepo(repoUrl, corsProxy, pgpKeyUrl) {
            const directoryPath = `/${repoUrl.split('/').pop().replace(/\.git$/, '')}`;
            console.log('Cloning repository to:', directoryPath);

            try {
                const dirExists = await pfs.stat(directoryPath);
                console.log(`${directoryPath} exists. Deleting old contents.`);
                await deleteDirectoryContents(directoryPath);
                await pfs.rmdir(directoryPath);
                console.log("Old directory contents were overwritten.");
            } catch (error) {
                if (error.code !== 'ENOENT') {
                    console.error("Error checking directory existence:", error);
                    return { error: `Error checking directory existence: ${error.message}` };
                } else {
                    console.log("Directory does not exist, no need to delete.");
                }
            }

            try {
                await git.clone({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    depth: undefined,
                });
                console.log('Repository cloned successfully.');

                await git.fetch({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    tags: true,
                });
                console.log('Fetched all branches and tags.');

                let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' });
                branches = branches.filter(branch => branch !== 'HEAD');
                console.log('Branches in cloned repo:', branches);

                for (const branch of branches) {
                    console.log(`Checking out branch: ${branch}`);
                    await git.checkout({ fs, dir: directoryPath, ref: branch });

                    const commits = await git.log({ fs, dir: directoryPath, ref: branch });
                    console.log(`Commits in branch ${branch}:`, commits);

                    for (const commit of commits) {
                        const data = commit.payload;
                        const armoredSignature = commit.commit.gpgsig;
                        let armoredPublicKey = null;

                        if (!armoredSignature) {
                            await deleteDirectoryContents(directoryPath);
                            await pfs.rmdir(directoryPath);
                            console.log(`No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`);
                            const repoInfo = await checkAndDisplayContent();
                            return { error: `No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`, repoInfo };
                        }

                        if (pgpKeyUrl) {
                            armoredPublicKey = await fetchPgpKey(pgpKeyUrl);
                        }

                        if (armoredPublicKey) {
                            const isValid = await verifySignature(data, armoredSignature, armoredPublicKey);
                            if (!isValid) {
                                await deleteDirectoryContents(directoryPath);
                                await pfs.rmdir(directoryPath);
                                console.log(`The signature for commit ${commit.oid} in branch ${branch} is invalid. Repository has been removed.`);
                                const repoInfo = await checkAndDisplayContent();
                                return { error: `The signature for commit ${commit.oid} in branch ${branch} is invalid. Repository has been removed.`, repoInfo };
                            }
                        } else {
                            await deleteDirectoryContents(directoryPath);
                            await pfs.rmdir(directoryPath);
                            console.log(`No valid PGP key provided. Repository was unverified and deleted.`);
                            const repoInfo = await checkAndDisplayContent();
                            return { error: `No valid PGP key provided. Repository was unverified and deleted.`, repoInfo };
                        }
                    }
                }

                console.log('All commits in all branches have been verified successfully.');
                const repoInfo = await checkAndDisplayContent();
                return { message: 'Repository cloned and verified successfully', repoInfo: repoInfo };

            } catch (error) {
                console.error("Cloning failed:", error);
                await deleteDirectoryContents(directoryPath);
                await pfs.rmdir(directoryPath);
                console.log("Failed directory was removed.");
                const repoInfo = await checkAndDisplayContent();
                return { error: `Cloning failed: ${error.message}`, repoInfo };
            }
        }

        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => {
                        reg.addEventListener('updatefound', () => {
                            const installingWorker = reg.installing;
                            console.log('A new service worker is being installed:', installingWorker);
                        });
                        console.log('Registration succeeded. Scope is ' + reg.scope);
                    })
                    .catch(error => {
                        console.log('Registration failed with ' + error);
                    });
            } else {
                console.log('Service workers are not supported in this browser.');
            }
        }

        async function fetchPgpKey(pgpKeyUrl) {
            try {
                console.log('Fetching PGP key from:', pgpKeyUrl);
                const response = await fetch(pgpKeyUrl);
                if (!response.ok) {
                    throw new Error('Failed to fetch PGP key');
                }
                const key = await response.text();
                console.log('PGP key fetched successfully.');
                return key;
            } catch (error) {
                console.error('Error fetching PGP key:', error);
                return null;
            }
        }

        async function deleteDirectoryContents(path) {
            const entries = await pfs.readdir(path);
            console.log(`Deleting contents of directory: ${path}`, entries);
            await Promise.all(entries.map(async (entry) => {
                const fullPath = `${path}/${entry}`;
                const stats = await pfs.stat(fullPath);
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(fullPath);
                    await pfs.rmdir(fullPath);
                } else {
                    await pfs.unlink(fullPath);
                }
            }));
            console.log(`Contents of directory ${path} deleted.`);
        }

        async function verifySignature(data, armoredSignature, armoredPublicKey) {
            console.log('Verifying signature...');
            const publicKey = await openpgp.readKey({ armoredKey: armoredPublicKey });
            const signature = await openpgp.readSignature({ armoredSignature });
            const message = await openpgp.createMessage({ text: data });

            try {
                const verificationResult = await openpgp.verify({
                    message,
                    signature,
                    verificationKeys: publicKey
                });
                const { verified, keyID } = verificationResult.signatures[0];
                await verified;
                console.log(`Signature verified successfully with key ID ${keyID.toHex()}`);
                return true;
            } catch (e) {
                console.error(`Signature verification failed: ${e}`);
                return false;
            }
        }

        async function updateCommitDropdown(directoryPath, branch, commitSelect) {
            try {
                console.log(`Updating commit dropdown for branch: ${branch} in directory: ${directoryPath}`);
                const commits = await git.log({ fs, dir: directoryPath, ref: branch });
                console.log(`Found ${commits.length} commits for branch: ${branch}`);

                commitSelect.innerHTML = '';
                for (const commit of commits) {
                    const commitOption = document.createElement('option');
                    commitOption.value = commit.oid;
                    commitOption.textContent = commit.commit.message ? commit.commit.message : commit.oid;
                    commitSelect.appendChild(commitOption);
                    console.log(`Added commit to dropdown: ${commit.oid}, message: ${commit.commit.message}`);
                }
            } catch (error) {
                console.error('Error updating commit dropdown:', error);
            }
        }

        async function checkoutCommit(directoryPath, branch, commit) {
            try {
                console.log(`Checking out commit: ${commit} in branch: ${branch} for directory: ${directoryPath}`);
                await git.checkout({ fs, dir: directoryPath, ref: commit, force: true });
                console.log(`Checked out commit ${commit} in branch ${branch}`);
            } catch (error) {
                console.error(`Error checking out commit ${commit} in branch ${branch}:`, error);
            }
        }

        document.getElementById('repoForm').addEventListener('submit', async function (event) {
            event.preventDefault();
            const repoUrl = document.getElementById('repoUrl').value;
            const pgpKeyUrl = document.getElementById('pgpKeyUrl').value;
            if (repoUrl && pgpKeyUrl) {
                document.getElementById('displayError').style.display = 'none';
                console.log('Cloning repository:', repoUrl);
                const result = await cloneRepo(repoUrl, corsProxy, pgpKeyUrl);
                console.log('Result from cloneRepo:', result);
                displayData(result);
            } else {
                document.getElementById('displayError').style.display = 'block';
                document.getElementById('displayError').innerText = 'Both repository URL and PGP Key URL must be provided.';
                console.log('Error: Both repository URL and PGP Key URL must be provided.');
            }
        });

        document.getElementById('deleteAllButton').addEventListener('click', async () => {
            console.log('Deleting all repositories...');
            await deleteAllRepos();
            const result = await checkAndDisplayContent();
            displayData({ repoInfo: result });
        });

        async function deleteAllRepos() {
            const rootDirEntries = await pfs.readdir('/');
            console.log('Root directory entries for deletion:', rootDirEntries);
            for (const entry of rootDirEntries) {
                const stats = await pfs.stat(`/${entry}`);
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(`/${entry}`);
                    await pfs.rmdir(`/${entry}`);
                    console.log(`Deleted directory: /${entry}`);
                }
            }
            console.log('All repositories have been deleted.');
        }

        async function deleteRepo(directoryPath, repoContainer) {
            try {
                if (directoryPath !== '/') {
                    await deleteDirectoryContents(directoryPath);
                    await pfs.rmdir(directoryPath);
                    console.log(`${directoryPath} directory deleted successfully.`);
                    repoContainer.remove();
                } else {
                    console.log('Cannot delete the root directory.');
                }
            } catch (err) {
                console.log(`Failed to delete ${directoryPath}.`, err);
            }
            const result = await checkAndDisplayContent();
            displayData({ repoInfo: result });
        }

        function displayData(data) {
            const reposContainer = document.getElementById('reposContainer');
            reposContainer.innerHTML = ''; // Clear existing content

            if (data.error) {
                console.log('Displaying error:', data.error);
                const displayError = document.getElementById('displayError');
                displayError.innerText = data.error;
                displayError.style.display = 'block';
            } else {
                document.getElementById('displayError').style.display = 'none';
            }

            if (!data.repoInfo || data.repoInfo.length === 0) {
                console.log('No repositories found.');
                document.getElementById('deleteAllRepos').style.display = 'none';
                return;
            }

            for (const repo of data.repoInfo) {
                console.log('Displaying repo:', repo.directory);

                const repoContainer = document.createElement('div');
                repoContainer.classList.add('repo-container', 'mb-3');

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete Repo';
                deleteBtn.classList.add('btn', 'btn-danger', 'mb-2');
                deleteBtn.addEventListener('click', async () => {
                    await deleteRepo(`/${repo.directory}`, repoContainer);
                });
                repoContainer.appendChild(deleteBtn);

                const contentDisplay = document.createElement('div');
                const directoryPath = `/${repo.directory}`;
                const dirEntries = pfs.readdir(directoryPath);
                dirEntries.then(entries => {
                    if (entries.includes('index.html')) {
                        contentDisplay.innerHTML = `<h3>${repo.directory}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                    } else {
                        contentDisplay.innerHTML = `<h3>${repo.directory}</h3>No index.html found in this directory.<br>`;
                    }
                });

                repoContainer.appendChild(contentDisplay);

                const branchSelect = document.createElement('select');
                branchSelect.classList.add('form-control', 'mb-2');
                repoContainer.appendChild(branchSelect);

                for (const branch of repo.branches) {
                    const branchOption = document.createElement('option');
                    branchOption.value = branch;
                    branchOption.textContent = branch;
                    if (branch === repo.currentBranch) {
                        branchOption.selected = true;
                    }
                    branchSelect.appendChild(branchOption);
                }

                const commitSelect = document.createElement('select');
                commitSelect.classList.add('form-control', 'mb-2');
                repoContainer.appendChild(commitSelect);

                branchSelect.addEventListener('change', async (event) => {
                    await updateCommitDropdown(directoryPath, branchSelect.value, commitSelect);
                });

                commitSelect.addEventListener('change', async (event) => {
                    await checkoutCommit(directoryPath, branchSelect.value, commitSelect.value);
                    const dirEntries = await pfs.readdir(directoryPath);
                    if (dirEntries.includes('index.html')) {
                        contentDisplay.innerHTML = `<h3>${repo.directory}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                    } else {
                        contentDisplay.innerHTML = `<h3>${repo.directory}</h3>No index.html found in this directory.<br>`;
                    }
                });

                updateCommitDropdown(directoryPath, branchSelect.value, commitSelect);

                reposContainer.appendChild(repoContainer);
                console.log('Repo displayed:', repo.directory);
            }
            document.getElementById('deleteAllRepos').style.display = 'block';
        }

        window.addEventListener('load', async () => {
            console.log('Page loaded. Checking and displaying content...');
            const result = await checkAndDisplayContent();
            displayData({ repoInfo: result });
        });

    </script>
</body>

</html>