<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS CDN for responsive design and styling -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
        integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <title>LightningFS and Isomorphic-git POC</title>
    <style>
        .repo-container {
            border: 1px solid #ccc;
            /* Light grey border */
            border-radius: 5px;
            /* Rounded corners */
            padding: 10px;
            /* Padding inside the container */
            margin-bottom: 10px;
            /* Margin at the bottom for spacing between containers */
        }
    </style>
</head>

<body>
    <div class="container mt-5">
        <h1 class="mb-3">LightningFS and Isomorphic-git POC</h1>
        <div id="staticDisplay" class="mt-3">
            <p>Navigate to the static page <a href="admin/index.html">here</a></p>
        </div>
        <!-- Clone control panel for inputting repo URL and PGP key URL -->
        <div id="cloneControlPanel" class="mb-3" style="display: none;">
            <form id="repoForm">
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <label for="repoUrl" class="sr-only">Repository URL</label>
                        <input type="url" class="form-control mb-2" id="repoUrl" placeholder="Enter repository URL"
                            required>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <label for="pgpKeyUrl" class="sr-only">PGP Key URL</label>
                        <input type="url" class="form-control mb-2" id="pgpKeyUrl" placeholder="Enter PGP Key URL"
                            required>
                    </div>
                </div>
                <div class="form-row align-items-center">
                    <div class="col-12 col-md-6">
                        <button type="submit" class="btn btn-primary mb-2">Clone Repo</button>
                    </div>
                </div>
            </form>
        </div>
        <!-- Error message display area -->
        <div id="displayError" class="alert alert-warning" role="alert" style="display: none;"></div>
        <!-- Container for displaying cloned repositories -->
        <div id="reposContainer" class="mt-3"></div>
        <!-- Delete all repositories button -->
        <div id="deleteAllRepos" class="mt-3 mb-3" style="display: none;">
            <button id="deleteAllButton" class="btn btn-danger">Delete All Repos</button>
        </div>
    </div>


    <!-- LightningFS and Isomorphic-git scripts for file system and git operations -->
    <script src="https://cdn.jsdelivr.net/npm/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/isomorphic-git@1.25.3/http/web/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval/dist/umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/openpgp@5.11.1/dist/openpgp.min.js"></script>

    <script>
        // Register the service worker to enable offline capabilities
        registerServiceWorker();

        // Initialize a new filesystem using LightningFS
        const fs = new LightningFS('testfs');
        const pfs = fs.promises; // Promises interface for asynchronous operations
        const corsProxy = 'https://sandstonemountain.com'; // CORS Proxy URL
        const errorDiv = document.getElementById('displayError'); // Error display div

        // Function to check and return the list of directories in the root
        async function checkContent() {
            try {
                const rootDirEntries = await pfs.readdir('/'); // Read root directory entries
                const dirStats = await Promise.all(rootDirEntries.map(async entry => {
                    const stats = await pfs.stat(`/${entry}`); // Get stats for each entry
                    return { entry, isDirectory: stats.isDirectory() }; // Return entry name and directory status
                }));
                return dirStats.filter(({ isDirectory }) => isDirectory).map(({ entry }) => entry); // Filter and map directory entries
            } catch (err) {
                console.log('Error reading directories:', err); // Log error if reading directories fails
                return [];
            }
        }

        // Function to recursively delete contents of a directory
        async function deleteDirectoryContents(path) {
            const entries = await pfs.readdir(path); // Read directory entries
            await Promise.all(entries.map(async entry => {
                const fullPath = `${path}/${entry}`; // Construct full path
                const stats = await pfs.stat(fullPath); // Get stats for each entry
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(fullPath); // Recursively delete subdirectory contents
                    await pfs.rmdir(fullPath); // Remove the now-empty subdirectory
                } else {
                    await pfs.unlink(fullPath); // Delete file
                }
            }));
        }

        // Function to delete a repository directory
        async function deleteRepo(directoryPath) {
            try {
                if (directoryPath !== '/') {
                    await deleteDirectoryContents(directoryPath); // Delete all contents within the directory
                    await pfs.rmdir(directoryPath); // Remove the directory itself
                    console.log(`${directoryPath} directory deleted successfully.`);
                } else {
                    console.log('Cannot delete the root directory.');
                }
            } catch (err) {
                console.log(`Failed to delete ${directoryPath}.`, err); // Log error if deletion fails
            }
        }

        // Function to register the service worker
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => {
                        reg.addEventListener('updatefound', () => {
                            const installingWorker = reg.installing;
                            console.log('A new service worker is being installed:', installingWorker);
                        });
                        console.log('Registration succeeded. Scope is ' + reg.scope);
                    })
                    .catch(error => {
                        console.log('Registration failed with ' + error);
                    });
            } else {
                console.log('Service workers are not supported in this browser.');
            }
        }

        // Function to fetch PGP key from a URL
        async function fetchPgpKey(pgpKeyUrl) {
            try {
                const response = await fetch(pgpKeyUrl); // Fetch PGP key
                if (!response.ok) {
                    throw new Error('Failed to fetch PGP key'); // Throw error if response is not OK
                }
                return await response.text(); // Return PGP key text
            } catch (error) {
                console.error('Error fetching PGP key:', error); // Log error if fetching fails
                return null;
            }
        }

        // Function to clone a repository
        async function cloneRepo(repoUrl, pgpKeyUrl) {
            const directoryPath = `/${repoUrl.split('/').pop().replace(/\.git$/, '')}`; // Construct directory path from repo URL

            try {
                const dirExists = await pfs.stat(directoryPath); // Check if directory exists
                await deleteDirectoryContents(directoryPath); // Delete existing contents if directory exists
                await pfs.rmdir(directoryPath); // Remove the directory
            } catch (error) {
                if (error.code !== 'ENOENT') {
                    console.error("Error checking directory existence:", error); // Log error if not ENOENT
                    throw new Error(`Error checking directory existence: ${error.message}`);
                }
            }

            try {
                // Clone the repository
                await git.clone({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    depth: undefined,
                });

                // Fetch all branches and tags
                await git.fetch({
                    fs,
                    http: GitHttp,
                    dir: directoryPath,
                    corsProxy: corsProxy,
                    url: repoUrl,
                    singleBranch: false,
                    tags: true,
                });

                // List all branches and filter out HEAD
                let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' });
                branches = branches.filter(branch => branch !== 'HEAD');

                for (const branch of branches) {
                    await git.checkout({ fs, dir: directoryPath, ref: branch }); // Checkout each branch
                    const commits = await git.log({ fs, dir: directoryPath, ref: branch }); // Get commit log

                    for (const commit of commits) {
                        const data = commit.payload;
                        const armoredSignature = commit.commit.gpgsig;
                        if (!armoredSignature) {
                            await deleteDirectoryContents(directoryPath); // Delete contents if no signature
                            await pfs.rmdir(directoryPath);
                            throw new Error(`No signature found for commit ${commit.oid} in branch ${branch}. Repository is unverified and has been removed.`);
                        }

                        const armoredPublicKey = await fetchPgpKey(pgpKeyUrl); // Fetch PGP key
                        if (armoredPublicKey && await verifySignature(data, armoredSignature, armoredPublicKey)) {
                            console.log(`Signature for commit ${commit.oid} in branch ${branch} is valid.`);
                        } else {
                            await deleteDirectoryContents(directoryPath); // Delete contents if signature invalid
                            await pfs.rmdir(directoryPath);
                            throw new Error(`The signature for commit ${commit.oid} in branch ${branch} is invalid. Repository has been removed.`);
                        }
                    }
                }

                return { success: true, directoryPath, branches }; // Return relevant data for rendering
            } catch (error) {
                console.error("Cloning failed:", error); // Log error if cloning fails
                return { success: false, message: error.message };
            }
        }

        // Display the cloning error message in the UI
        function displayErrorMessage(message) {
            errorDiv.innerHTML = message; // Set the error message
            errorDiv.style.display = 'block'; // Display the error message div
        }

        // Function to verify the signature of a commit using OpenPGP.js
        async function verifySignature(data, armoredSignature, armoredPublicKey) {
            const publicKey = await openpgp.readKey({ armoredKey: armoredPublicKey }); // Read PGP public key
            const signature = await openpgp.readSignature({ armoredSignature }); // Read PGP signature
            const message = await openpgp.createMessage({ text: data }); // Create a message from the commit data

            try {
                const verificationResult = await openpgp.verify({
                    message,
                    signature,
                    verificationKeys: publicKey
                });
                const { verified, keyID } = verificationResult.signatures[0];
                await verified; // Await the verification result
                console.log(`Signature verified successfully with key ID ${keyID.toHex()}`);
                return true;
            } catch (e) {
                console.error(`Signature verification failed: ${e}`);
                return false;
            }
        }

        // Function to update commit dropdown with commits from a branch
        async function updateCommitDropdown(directoryPath, branch, commitSelect) {
            try {
                console.log(`Updating commit dropdown for branch: ${branch}`);
                // Get commits for the selected branch
                const commits = await git.log({ fs, dir: directoryPath, ref: branch });

                // Clear existing options
                commitSelect.innerHTML = '';

                if (commits.length === 0) {
                    console.log(`No commits found for branch: ${branch}`);
                } else {
                    console.log(`Found ${commits.length} commits for branch: ${branch}`);
                }

                // Add commit options to dropdown
                for (const commit of commits) {
                    console.log(`Adding commit: ${commit.oid}, message: ${commit.commit.message}`);
                    const commitOption = document.createElement('option');
                    commitOption.value = commit.oid;
                    commitOption.textContent = `${commit.oid.slice(0, 7)} - ${commit.commit.message.split('\n')[0]}`;
                    commitSelect.appendChild(commitOption);
                }

                // Get the current commit
                const currentCommit = await git.resolveRef({ fs, dir: directoryPath, ref: 'HEAD' });

                // Set the current commit as selected
                if (currentCommit) {
                    const currentCommitOption = Array.from(commitSelect.options).find(option => option.value === currentCommit);
                    if (currentCommitOption) {
                        currentCommitOption.selected = true;
                    }
                }
            } catch (error) {
                console.error('Error updating commit dropdown:', error);
            }
        }

        // Function to checkout a specific commit
        async function checkoutCommit(directoryPath, branch, commit) {
            try {
                console.log(`Checking out commit: ${commit} in branch: ${branch}`);

                // First, checkout the branch
                await git.checkout({ fs, dir: directoryPath, ref: branch });

                // Then, if a specific commit is provided, checkout that commit
                if (commit) {
                    await git.checkout({ fs, dir: directoryPath, ref: commit });
                }

                console.log(`Checked out commit ${commit} in branch ${branch}`);

                // Update the content display after checkout
                await updateContentDisplay(directoryPath);
            } catch (error) {
                console.error(`Error checking out commit ${commit} in branch ${branch}:`, error);
            }
        }

        // Function to render the repositories and related UI elements
        async function renderRepos() {
            // Get list of directories (repositories)
            const directories = await checkContent();
            const reposContainer = document.getElementById('reposContainer');
            reposContainer.innerHTML = ''; // Clear existing content

            // Show clone control panel
            const cloneControlPanel = document.getElementById('cloneControlPanel');
            cloneControlPanel.style.display = 'block';

            if (directories.length > 0) {
                for (const dir of directories) {
                    let directoryPath = `/${dir}`;
                    const dirEntries = await pfs.readdir(directoryPath);

                    if (dirEntries.length > 0) {
                        // Create container for each repository
                        const repoContainer = document.createElement('div');
                        repoContainer.classList.add('repo-container', 'mb-3');
                        reposContainer.appendChild(repoContainer);

                        // Create delete button for the repository
                        const deleteBtn = document.createElement('button');
                        deleteBtn.textContent = 'Delete Repo';
                        deleteBtn.classList.add('btn', 'btn-danger', 'mb-2');
                        deleteBtn.addEventListener('click', async () => {
                            await deleteRepo(directoryPath);
                            renderRepos();
                        });
                        repoContainer.appendChild(deleteBtn);

                        // Create content display area
                        const contentDisplay = document.createElement('div');
                        contentDisplay.dataset.directory = directoryPath;
                        if (dirEntries.includes('index.html')) {
                            contentDisplay.innerHTML = `<h3>${dir}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                        } else {
                            contentDisplay.innerHTML = `<h3>${dir}</h3>No index.html found in this directory.<br>`;
                        }
                        repoContainer.appendChild(contentDisplay);

                        // Create branch select dropdown
                        const branchSelect = document.createElement('select');
                        branchSelect.classList.add('form-control', 'mb-2');
                        repoContainer.appendChild(branchSelect);

                        // Create commit select dropdown
                        const commitSelect = document.createElement('select');
                        commitSelect.classList.add('form-control', 'mb-2');
                        repoContainer.appendChild(commitSelect);

                        // Get current branch and commit
                        const { branch: currentBranch, commit: currentCommit } = await getCurrentBranchAndCommit(directoryPath);

                        // Populate branch select dropdown
                        let branches = await git.listBranches({ fs, dir: directoryPath, remote: 'origin' });
                        branches = branches.filter(branch => branch !== 'HEAD');

                        for (const branch of branches) {
                            const branchOption = document.createElement('option');
                            branchOption.value = branch;
                            branchOption.textContent = branch;
                            if (branch === currentBranch) {
                                branchOption.selected = true;
                            }
                            branchSelect.appendChild(branchOption);
                        }

                        // Add event listener for branch change
                        branchSelect.addEventListener('change', async (event) => {
                            await updateCommitDropdown(directoryPath, branchSelect.value, commitSelect);
                        });

                        // Add event listener for commit change
                        commitSelect.addEventListener('change', async (event) => {
                            await checkoutCommit(directoryPath, branchSelect.value, commitSelect.value);
                        });

                        // Update commit dropdown for current branch
                        await updateCommitDropdown(directoryPath, currentBranch || branches[0], commitSelect);

                        // Set current commit as selected
                        if (currentCommit) {
                            commitSelect.value = currentCommit;
                        }

                        // Handle detached HEAD state
                        if (!currentBranch && currentCommit) {
                            const commitOption = Array.from(commitSelect.options).find(option => option.value === currentCommit);
                            if (commitOption) {
                                commitOption.selected = true;
                            }
                        }

                        reposContainer.appendChild(repoContainer);
                    }
                }
                document.getElementById('deleteAllRepos').style.display = 'block';
            } else {
                document.getElementById('deleteAllRepos').style.display = 'none';
            }

            // Debug: List all directory contents
            listAllDirectoryContents();
        }

        // Function to get the current branch and commit for a repository
        async function readHEADFile(directoryPath) {
            try {
                // Read the contents of the HEAD file
                const headContent = await pfs.readFile(`${directoryPath}/.git/HEAD`, { encoding: 'utf8' });
                return headContent.trim();
            } catch (error) {
                console.error('Error reading HEAD file:', error);
                return null;
            }
        }

        // Function to get the current branch and commit for a repository
        async function getCurrentBranchAndCommit(directoryPath) {
            const headContent = await readHEADFile(directoryPath);
            if (!headContent) return { branch: null, commit: null };

            if (headContent.startsWith('ref: refs/heads/')) {
                // We're on a branch
                const branch = headContent.replace('ref: refs/heads/', '');
                const commit = await git.resolveRef({ fs, dir: directoryPath, ref: branch });
                return { branch, commit };
            } else {
                // We're in detached HEAD state
                return { branch: null, commit: headContent };
            }
        }

        // Function to update the content display based on the current branch and commit
        async function updateContentDisplay(directoryPath) {
            // Read directory contents
            const dirEntries = await pfs.readdir(directoryPath);
            // Find the content display element for this repository
            const contentDisplay = document.querySelector(`[data-directory="${directoryPath}"]`);
            if (contentDisplay) {
                // Update the content display based on whether index.html exists
                if (dirEntries.includes('index.html')) {
                    contentDisplay.innerHTML = `<h3>${directoryPath.slice(1)}</h3>Navigate to the cloned page <a href="${directoryPath}/index.html">here</a><br>`;
                } else {
                    contentDisplay.innerHTML = `<h3>${directoryPath.slice(1)}</h3>No index.html found in this directory.<br>`;
                }
            }
        }

        // Function to delete all repositories
        async function deleteAllRepos() {
            const rootDirEntries = await pfs.readdir('/'); // Read root directory entries
            for (const entry of rootDirEntries) {
                const stats = await pfs.stat(`/${entry}`); // Get stats for each entry
                if (stats.isDirectory()) {
                    await deleteDirectoryContents(`/${entry}`); // Recursively delete directory contents
                    await pfs.rmdir(`/${entry}`); // Remove directory
                }
            }
        }

        // Debug function to list all directory contents for cloned repositories
        async function listAllDirectoryContents() {
            try {
                const rootDirEntries = await pfs.readdir('/');
                for (const entry of rootDirEntries) {
                    const stats = await pfs.stat(`/${entry}`);
                    if (stats.isDirectory()) {
                        const dirPath = `/${entry}`;
                        const dirContents = await pfs.readdir(dirPath);
                        console.log(`Contents of ${dirPath}:`, dirContents);
                    }
                }
            } catch (err) {
                console.error('Error listing directory contents:', err);
            }
        }

        // Attach event listener to repository form for cloning
        document.getElementById('repoForm').addEventListener('submit', async function (event) {
            event.preventDefault(); // Prevent default form submission
            const repoUrl = document.getElementById('repoUrl').value; // Get repository URL
            const pgpKeyUrl = document.getElementById('pgpKeyUrl').value; // Get PGP key URL
            if (repoUrl && pgpKeyUrl) {
                errorDiv.style.display = 'none'; // Hide error message div
                const result = await cloneRepo(repoUrl, pgpKeyUrl); // Clone repository
                if (result.success) {
                    renderRepos(); // Re-render repositories on success
                } else {
                    displayErrorMessage(result.message); // Display error message if cloning fails
                }
            } else {
                displayErrorMessage('Please fill in both the repository and the PGP Key URLs.'); // Display error if fields are empty
            }
        });

        // Attach event listener to delete all repositories button
        document.getElementById('deleteAllButton').addEventListener('click', async () => {
            await deleteAllRepos(); // Delete all repositories on button click
            renderRepos(); // Re-render repositories
        });

        // Initial render of repositories on page load
        renderRepos();
    </script>
</body>

</html>